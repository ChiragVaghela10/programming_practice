Reference: http://interactivepython.org/runestone/static/thinkcspy/GUIandEventDrivenProgramming/toctree.html
1. -> A GUI program’s interface is composed of widgets displayed in a window. Your computer’s operating system controls the creation and manipulation of windows on your computer’s display screen. The operating system also controls the pointing devices on your computer, such as a mouse or a touch screen. Therefore, your computer’s operating system is what recognizes events that happen in a window. Your operating system sends events to your program in the order they are generated by a user. Your program’s event-loop responds to these events. All GUI programs have the same event-loop, so there is an event-loop provided for you and it looks something like below program.

A typical GUI program looks like this:

while True:
  # Get the next event from the operating system
  event = get_next_event()

  # Get the function that is assigned to handle this event
  a_function_to_handle_the_event = event-handlers[event]

  # If a function has been assigned to handle this event, call the function
  if a_function_to_handle_the_event:
    a_function_to_handle_the_event()  # Call the event-handler function

  # Stop processing events if the user gives a command to stop the application
  if window_needs_to_close:
    break  # out of the event-loop
while True:
  # Get the next event from the operating system
  event = get_next_event()

  # Get the function that is assigned to handle this event
  a_function_to_handle_the_event = event-handlers[event]

  # If a function has been assigned to handle this event, call the function
  if a_function_to_handle_the_event:
    a_function_to_handle_the_event()  # Call the event-handler function

  # Stop processing events if the user gives a command to stop the application
  if window_needs_to_close:
    break  # out of the event-loop

Again, you do not implement an event-loop in a GUI program. The event loop has already been written for you. You make this event-loop work by associating a function (which is called an event-handler or a callback function) to a specific event.

2. -> Your 'hello world' program would be like this:

import tkinter as tk
from tkinter import ttk

# Create the application window
window = tk.Tk()

# Create the user interface
my_label = ttk.Label(window, text="Hello World!")
my_label.grid(row=1, column=1)

# Start the GUI event loop
window.mainloop()

3. -> Dialogboxes:
from tkinter import messagebox

messagebox.showinfo("Information","Informative message")
messagebox.showerror("Error", "Error message")
messagebox.showwarning("Warning","Warning message")

4. -> Yes/No Questions:
from tkinter import messagebox

answer = messagebox.askokcancel("Question","Do you want to open this file?")
answer = messagebox.askretrycancel("Question", "Do you want to try that again?")
answer = messagebox.askyesno("Question","Do you like Python?")
answer = messagebox.askyesnocancel("Question", "Continue playing?")

5. -> Single Value Data Entry:
import tkinter as tk
from tkinter import simpledialog

application_window = tk.Tk()

answer = simpledialog.askstring("Input", "What is your first name?",
                                parent=application_window)
if answer is not None:
    print("Your first name is ", answer)
else:
    print("You don't have a first name?")

answer = simpledialog.askinteger("Input", "What is your age?",
                                 parent=application_window,
                                 minvalue=0, maxvalue=100)
if answer is not None:
    print("Your age is ", answer)
else:
    print("You don't have an age?")

answer = simpledialog.askfloat("Input", "What is your salary?",
                               parent=application_window,
                               minvalue=0.0, maxvalue=100000.0)
if answer is not None:
    print("Your salary is ", answer)
else:
    print("You don't have a salary?")
    
6. -> File selector:
import tkinter as tk
from tkinter import filedialog
import os

application_window = tk.Tk()

# Build a list of tuples for each file type the file dialog should display
my_filetypes = [('all files', '.*'), ('text files', '.txt')]

# Ask the user to select a folder.
answer = filedialog.askdirectory(parent=application_window,
                                 initialdir=os.getcwd(),
                                 title="Please select a folder:")

# Ask the user to select a single file name.
answer = filedialog.askopenfilename(parent=application_window,
                                    initialdir=os.getcwd(),
                                    title="Please select a file:",
                                    filetypes=my_filetypes)

# Ask the user to select a one or more file names.
answer = filedialog.askopenfilenames(parent=application_window,
                                     initialdir=os.getcwd(),
                                     title="Please select one or more files:",
                                     filetypes=my_filetypes)

# Ask the user to select a single file name for saving.
answer = filedialog.asksaveasfilename(parent=application_window,
                                      initialdir=os.getcwd(),
                                      title="Please select a file name for saving:",
                                      filetypes=my_filetypes)
                                      
They simply allow a user to select a file. Once you have the file name, you can open, process, and close the file using appropriate Python code. These dialog boxes always return you a “fully qualified file name” that includes a full path to the file. Also note that if a user is allowed to select multiple files, the return value is a tuple that contains all of the selected files. If a user cancels the dialog box, the returned value is an empty string.

7. -> Color chooser (rarely used):
from tkinter import colorchooser

rgb_color, web_color = colorchooser.askcolor(parent=application_window,
                                             initialcolor=(255, 0, 0))
                                             
8. -> GUI Widgets (Useful):
# To use the "generic" widgets
import tkinter as tk

# To use the stylized, "look-and-feel" or 'OS native' widgets
from tkinter import ttk
NOTE: You always need to import the tk functionality because that allows you to create an application window. check all_user_input_widgets.py to see them working.

9. -> Creating Widgets(Useful):

After importing the Tkinter modules as shown above, the first thing you need to do is create a window for your application. This is done by creating a Tk object:

application_window = tk.Tk()

Then you create widgets and add them to the window’s widget hierarchy. For example, to create a button you would call either the tk or the tkk Button method and send the application_window as the first argument:

cmd_button = tk.Button(application_window, text="Example")

10. -> Layout Managers (Very Useful):

NOTE: "A widget will not be visible in a window until you assign it a size and location within it’s parent widget."
Assigning a specific size and location to every widget is tedious and error-prone. In addition, the desired behaviour for most GUI interfaces is that the widgets resize and relocate in reasonable ways if their parent window is re-sized. Therefore, layout managers are included in the Tkinter module to do this work for you. You just have to give some basic positioning information to a layout manager so it can calculate a position and a size for each widget.
There are three layout managers in the Tkinter module:

Layout Manager		Description
place				You specify the exact size and position of each widget.

pack				You specify the size and position of each widget relative to each other.

grid				You place widgets in a cell of a 2-dimensional table defined by rows and columns.

NOTE: "You should never mix and match these layout managers." Use only one of them for the widget layout within a particular “parent widget”. Widgets are organized in a hierarchy.

a) 'place' layout manager:
	All widgets have a ' .place(x, y, width, height)' method that can be used to specify the exact location and size of a widget. You can use this method to create a static interface that will always look the same regardless of the parent’s window size. This layout method is rarely used because the GUI window can’t be easily re-sized.
	
b) 'Grid' Layout Manager:
	All widgets have a ' .grid(row=r, column=c)' method that will place a widget in the cell (r,c) of a 2-D table. By default the widget is rendered in the middle of the cell and as small as possible. This can be changed using other optional parameters. The 'sticky' option allows you to move or stretch a widget to the borders of a cell. There are 4 options, 'tk.E, tk.W, tk.N, and tk.S', which are abbreviations for east, west, north, and south respectively. 
	
sticky Parameter			Description
tk.W						Move the widget to the left cell boundary.
tk.W + tk.N					Move the widget left and up so that it is in the upper-left corner.
tk.E + tk.W					Stretch the widget so that it fills the cell horizontally.
tk.E + tk.W + tk.S			Stretch the widget so that it fills the cell horizontally and move it down to the bottom cell boundary.
tk.E + tk.W + tk.N + tk.S	Stretch the widget so it fills the entire cell.

If you do not want the widget to be rendered as small as possible, you can add space to the widget using 'ipadx' and 'ipady', which makes the widget itself larger. (The “i” stands for internal padding.) Or you can add space around the widget to force a cell to be larger using 'padx' and 'pady'. (see all_user_input_widgets.py)
You can also have a widget span more than one cell in the grid using columnspan and rowspan parameters.

You might think that you need to tell tkinter how big your grid layout is – but you don’t. It will figure out how big the grid table is by simply examining all of the widgets inside a container widget. If there are cells that were not assigned a widget, those cells will be empty in the interface.

c) 'Pack' Layout Manager: doesn't seem useful. see you can see here if you want: http://interactivepython.org/runestone/static/thinkcspy/GUIandEventDrivenProgramming/04_layout_managers.html

11. -> Widget Groupings: Tkinter has four basic ways to group widgets(see below). They are often referred to as “container” widgets because they are the parent widget of a group of related widgets.

Widget					Purpose
tk.Frame, tkk.Frame		Create a container for a set of widgets to be displayed as a unit.

tkk.LabelFrame			Group a number of related widgets using a border and a title.

tk.PanedWindow			Group one or more widgets into “panes”, where the “panes” can be re-sized by the user by dragging separator lines.
tkk.Notebook			A tabbed set of frames, only one of which is visible at any given time.

Widgets are always organized as a hierarchy, where the main application window is the root of the hierarchy. he child widgets of an application window are a combination of “frames”. The “frames” hold other widgets like buttons etc.
NOTE: A “frame” will not be visible until it is assigned a size and location using a layout manager.
see all_frame_widgets.py, The “containers” in this example used a grid layout manager on a 2x2 grid.

For the '.Frame()' and '.LabelFrame()' groups, the frame is the “parent” of the widgets displayed inside the frame. That is, when the buttons were created, the frame was the first parameter to the 'tk.Button()' function.

For the '.PanedWindow()' and '.Notebook()' groups, you use an .add(widget) function to add your widgets to the group. You are still creating a hierarchy of widgets, but the syntax is different.

12. -> Command Events(Very Useful): When a user clicks on certain types of widgets, like a button, you typically want a specific action to be performed. This is accomplished by setting the command attribute of a widget to a specific event handler function.

You can set the event handler function using a “named parameter” when you create the widget, or set the widget’s command attribute using a dictionary lookup. For example:

def my_function():
  print("my_function was called.")

my_button = tk.Button(application_window, text="Example", command=my_function)

# or

my_button = tk.Button(application_window, text="Example")
my_button['command'] = my_function

Note that you are setting the command property of the widget to a function reference – you are not calling the function! Therefore, do not put parentheses after the function name.
The following widgets define a command property:
Widget			The user event that causes the command function to be executed:
Button			The user places their pointing device cursor over the button and presses and releases the left mouse button. The 					function is actually called on the button release.
Checkbutton		If the state of the check box changes, the function is called.

Radiobutton		If the state of the radio box changes, the function is called.

Scale			The function is called if the slider moves. The function is passed one argument, the new scale value.

The following widgets do not have a command property, but they use other properties to respond to user events:
Widget		Property		User events:
Menu		postcommand		Every time someone brings up this menu.

Combobox	postcommand		When the user clicks on the down-arrow.

Combobox	validatecommand	Dynamically validate the widget’s text content.

Entry		validatecommand	Dynamically validate the widget’s text content.

These don't respond to user events, hence no associated event handlers: Label, Message, and Separator.

13. -> Low-level event binding: For simple GUI programs, associating simple user actions with the most common user events, such as clicking on a button is sufficient. But for more complex programs you might need to process “lower level” events, such as recognizing when the user’s cursor is over a widget, or when a widget becomes the focus of user input. To handle these types of events you need to implement event binding.

14. -> Focus(Very Useful): Remember from our previous discussion that the operating system is in control of your computer’s screen, keyboard, mouse, and other input devices. When the user interacts with these input devices the operating system generates 'event objects' that capture specific event information. Your computer is running multiple processes at any given time, so how does the computer know which process to send an event to? All GUI operating systems have the concept of an “active window.” Only the “active window” receives events. We say that the “active window” has the 'focus' of the user. Typically the application whose window is in front of all other windows on the computer screen has the operating system’s 'focus'. Only the process with the 'focus' receives user events; the other running applications do 'not' receive user events.

The concept of 'focus' goes further than the applications running on a computer to the widget level in application. INSIDE AN APPLICATION ALSO, only one widget at a time can have the 'focus' of the user. The widget with the 'focus' is the widget that receives keyboard events.

15. -> Event Binding(Very Useful): When your program has the focus it can potentially receive many events to process. The task of associating a specific event handler function with a specific “low level” event is called binding.

An event is always 'bound' to a specific widget. For example, if you wanted to know when the cursor of a pointing device has moved over a widget, you would bind an "<Enter>" event to the widget and specify a function to call when the event happens. This is done with the ' .bind(event_description, event_handler)' method of a widget. Once this bind operation is complete and the application’s main event loop has started, every time a pointing device is moved over the widget, the event handler will be called.

Here is an example of binding an "<Enter>" event to a Button:

def process_event(event):
  print("The process_event function was called.")

my_button = tk.Button(application_window, text="Example")
my_button.bind("<Enter>", process_event) # "<Enter>" is an event descriptor    #note here .bind() is called instead of using 											 #'command' parameter.

In Tkinter, events are defined as strings using a pre-defined syntax. The general format of an event description is <modifier-type-detail>, where the modifier and detail portions are optional. For example, a <Button> event is generated by any change of state of any mouse button, while a <Shift-Button> event will only be generated if the mouse state changes while the SHIFT key on the keyboard is down.

Pointer Related Events		Description
"<ButtonPress-1/2/3>"		The left/middle/right mouse button was pressed.
"<B1/B2/B3-Motion>"			With the left/middle/right mouse button held down, the mouse changed location.
"<ButtonRelease-1>"			The left mouse button was released.
"<Double-Button-1>"			The left mouse button was double-clicked.
"<Enter>"					The mouse pointer just moved over a particular widget.
"<Leave>"					The mouse pointer is no longer over a particular widget.
"<FocusIn>"					A widget just received the keyboard focus.
"<FocusOut>"				A widget just lost the keyboard focus.
"<Configure>"				A widget just changed its size or position.

Keyboard Related Events		Description
"<Key>"						The user pressed any key on the keyboard.
"<Return>"/"<Backspace>"/"<Tab>"/"<Escape>"/"<Prior>"/"<Next>"/"<Up>"/"<Down>"/"<Left>"/"<Right>"/"<F1>"/"<a>"/"<Shift-Up>"/"<Alt-Up>"/"<Control-Up>"...
The user pressed the Enter/Backspace/Tab/Escape/Page-up/Page-down/up/down/left/right arrow/F1/“a”/up arrow + shift/Alt + shift/Ctrl + shift key.

16. -> Event objects(Very Useful): 
NOTE(VERY IMPORTANT):When a user generates an event, or the software generates an event, an 'event object' is created. This object is automatically passed to the function that is registered to handle the event. Every event handler function that is bound to an event using the ' .bind(event_description, function_handler)' (compare it with 'command' parameter). 

Function must be defined to receive one parameter, an 'event' object. e.g.:

def process_event(event):
  if event.x > 10 and event.y > 20:
    # do something
    
An event object contains the following attributes:
Attribute			Description
.widget				The widget this event was bound to. This is a reference to a Tkinter widget instance; it is not a string name.
.x, .y				The current mouse position, relative to the application’s window, in pixels.
.x_root, .y_root	The current mouse position relative to the upper left corner of the screen, in pixels.
.char				For keyboard events only, this is the character code of the key pressed or released as a string.
.keysym				For keyboard events only, the key symbol.
.keycode			For keyboard events only, the key code (i.e., the key’s Unicode decimal value).
.num				For mouse button events only, the button number.
.width, .height		For configure events only, the new size of the widget, in pixels.

17. -> Event Processing(Extremely Useful):
The operating system generates events in the order the user or the program creates them. An application’s GUI event loop receives the events in this same order and then calls the appropriate event handler. Therefore, events are processed in the same order they are created.

Events can’t be processed unless the application’s GUI event-loop is running. If an individual event handler takes a long time to process an event, other events will get “queued up” waiting for a chance to be processed. It is considered bad GUI programming for any event handler to take up too much processing time. An event handler should do as little processing as possible to accomplish its intended task and then quit. This returns control of the application back to the event loop.

Events are always associated with a widget. If you want to know every event that happens inside an application’s window, then bind events to the widget that is your application’s window. If you only want to know about button click events on a particular button, then bind an event handler to that specific button. In general, events should be associated with the most specific widget possible.











